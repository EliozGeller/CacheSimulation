//
// Generated file, do not edit! Created by nedtool 5.6 from messages.msg.
//

#ifndef __CACHESIMULATION_MESSAGES_M_H
#define __CACHESIMULATION_MESSAGES_M_H

#if defined(__clang__)
#  pragma clang diagnostic ignored "-Wreserved-id-macro"
#endif
#include <omnetpp.h>

// nedtool version check
#define MSGC_VERSION 0x0506
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of nedtool: 'make clean' should help.
#endif


namespace cachesimulation {

/**
 * Class generated from <tt>messages.msg:21</tt> by nedtool.
 * <pre>
 * packet DataPacket
 * {
 *     uint64_t destination;
 *     uint64_t external_destination = 0;
 *     int miss_hop = 0;
 *     string id;
 *     int request = 0; //Indicates whether this is an elephant packet and whether the switch wishes to insert the appropriate rule
 *     uint64_t flow_size = 0;
 *     double rate;
 *     int first_packet = 0;
 *     bool last_packet = false;
 * }
 * </pre>
 */
class DataPacket : public ::omnetpp::cPacket
{
  protected:
    uint64_t destination;
    uint64_t external_destination;
    int miss_hop;
    ::omnetpp::opp_string id;
    int request;
    uint64_t flow_size;
    double rate;
    int first_packet;
    bool last_packet;

  private:
    void copy(const DataPacket& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const DataPacket&);

  public:
    DataPacket(const char *name=nullptr, short kind=0);
    DataPacket(const DataPacket& other);
    virtual ~DataPacket();
    DataPacket& operator=(const DataPacket& other);
    virtual DataPacket *dup() const override {return new DataPacket(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint64_t getDestination() const;
    virtual void setDestination(uint64_t destination);
    virtual uint64_t getExternal_destination() const;
    virtual void setExternal_destination(uint64_t external_destination);
    virtual int getMiss_hop() const;
    virtual void setMiss_hop(int miss_hop);
    virtual const char * getId() const;
    virtual void setId(const char * id);
    virtual int getRequest() const;
    virtual void setRequest(int request);
    virtual uint64_t getFlow_size() const;
    virtual void setFlow_size(uint64_t flow_size);
    virtual double getRate() const;
    virtual void setRate(double rate);
    virtual int getFirst_packet() const;
    virtual void setFirst_packet(int first_packet);
    virtual bool getLast_packet() const;
    virtual void setLast_packet(bool last_packet);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const DataPacket& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, DataPacket& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>messages.msg:34</tt> by nedtool.
 * <pre>
 * packet InsertionPacket
 * {
 *     uint64_t rule;
 *     int type; //Push or Pull //delete
 *     int switch_type; //ToR,Aggregation or controller switch
 *     int destination; //The switch id
 *     int s;
 * }
 * </pre>
 */
class InsertionPacket : public ::omnetpp::cPacket
{
  protected:
    uint64_t rule;
    int type;
    int switch_type;
    int destination;
    int s;

  private:
    void copy(const InsertionPacket& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const InsertionPacket&);

  public:
    InsertionPacket(const char *name=nullptr, short kind=0);
    InsertionPacket(const InsertionPacket& other);
    virtual ~InsertionPacket();
    InsertionPacket& operator=(const InsertionPacket& other);
    virtual InsertionPacket *dup() const override {return new InsertionPacket(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint64_t getRule() const;
    virtual void setRule(uint64_t rule);
    virtual int getType() const;
    virtual void setType(int type);
    virtual int getSwitch_type() const;
    virtual void setSwitch_type(int switch_type);
    virtual int getDestination() const;
    virtual void setDestination(int destination);
    virtual int getS() const;
    virtual void setS(int s);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const InsertionPacket& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, InsertionPacket& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>messages.msg:43</tt> by nedtool.
 * <pre>
 * packet Data_for_partition
 * {
 *     uint64_t counters[100]; //Should be the size of the aggregation number
 * }
 * </pre>
 */
class Data_for_partition : public ::omnetpp::cPacket
{
  protected:
    uint64_t counters[100];

  private:
    void copy(const Data_for_partition& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Data_for_partition&);

  public:
    Data_for_partition(const char *name=nullptr, short kind=0);
    Data_for_partition(const Data_for_partition& other);
    virtual ~Data_for_partition();
    Data_for_partition& operator=(const Data_for_partition& other);
    virtual Data_for_partition *dup() const override {return new Data_for_partition(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual unsigned int getCountersArraySize() const;
    virtual uint64_t getCounters(unsigned int k) const;
    virtual void setCounters(unsigned int k, uint64_t counters);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Data_for_partition& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Data_for_partition& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>messages.msg:48</tt> by nedtool.
 * <pre>
 * packet Partition_update_msg
 * {
 *     uint64_t lows[100]; //Should be the size of the aggregation number
 *     uint64_t highs[100]; //Should be the size of the aggregation number
 *     int ports[100]; //Should be the size of the aggregation number
 * }
 * </pre>
 */
class Partition_update_msg : public ::omnetpp::cPacket
{
  protected:
    uint64_t lows[100];
    uint64_t highs[100];
    int ports[100];

  private:
    void copy(const Partition_update_msg& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Partition_update_msg&);

  public:
    Partition_update_msg(const char *name=nullptr, short kind=0);
    Partition_update_msg(const Partition_update_msg& other);
    virtual ~Partition_update_msg();
    Partition_update_msg& operator=(const Partition_update_msg& other);
    virtual Partition_update_msg *dup() const override {return new Partition_update_msg(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual unsigned int getLowsArraySize() const;
    virtual uint64_t getLows(unsigned int k) const;
    virtual void setLows(unsigned int k, uint64_t lows);
    virtual unsigned int getHighsArraySize() const;
    virtual uint64_t getHighs(unsigned int k) const;
    virtual void setHighs(unsigned int k, uint64_t highs);
    virtual unsigned int getPortsArraySize() const;
    virtual int getPorts(unsigned int k) const;
    virtual void setPorts(unsigned int k, int ports);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Partition_update_msg& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Partition_update_msg& obj) {obj.parsimUnpack(b);}

} // namespace cachesimulation

#endif // ifndef __CACHESIMULATION_MESSAGES_M_H

